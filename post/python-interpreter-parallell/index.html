<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Implementation Python Interpreter Parallel in Python 3.10 | xiejunyi blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="在业务场景中，我们通过cpython执行算法包，由于cpython的实现，在一个进程内，无法利用CPU的多个核心去同时执行算法包。对此，我们">
    <meta name="generator" content="Hugo 0.110.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Implementation Python Interpreter Parallel in Python 3.10" />
<meta property="og:description" content="在业务场景中，我们通过cpython执行算法包，由于cpython的实现，在一个进程内，无法利用CPU的多个核心去同时执行算法包。对此，我们" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/python-interpreter-parallell/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-31T15:43:48+08:00" />
<meta property="article:modified_time" content="2021-03-31T15:43:48+08:00" />
<meta itemprop="name" content="Implementation Python Interpreter Parallel in Python 3.10">
<meta itemprop="description" content="在业务场景中，我们通过cpython执行算法包，由于cpython的实现，在一个进程内，无法利用CPU的多个核心去同时执行算法包。对此，我们"><meta itemprop="datePublished" content="2021-03-31T15:43:48+08:00" />
<meta itemprop="dateModified" content="2021-03-31T15:43:48+08:00" />
<meta itemprop="wordCount" content="4135">
<meta itemprop="keywords" content="python,interpreter,optimization,performance,Parallel," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Implementation Python Interpreter Parallel in Python 3.10"/>
<meta name="twitter:description" content="在业务场景中，我们通过cpython执行算法包，由于cpython的实现，在一个进程内，无法利用CPU的多个核心去同时执行算法包。对此，我们"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        xiejunyi blog
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/" title="This is Home page">
              This is Home
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Archives page">
              Archives
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/tags/" title="Tags page">
              Tags
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/categories/" title="Categories page">
              Categories
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Implementation Python Interpreter Parallel in Python 3.10</h1>
      
      <p class="tracked">
        By <strong>xiejunyi</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-03-31T15:43:48+08:00">March 31, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>在业务场景中，我们通过cpython执行算法包，由于cpython的实现，在一个进程内，无法利用CPU的多个核心去同时执行算法包。对此，我们决定优化cpython，<strong>目标是让cpython高完成度的支持并行，大幅度的提高单个进程内Python算法包的执行效率。</strong></p>
<p>在2020年，我们完成了对cpython的并行执行改造，是目前业界首个cpython3的高完成度同时兼容Python C API的并行实现。</p>
<ul>
<li>性能
<ul>
<li>单线程性能劣化7.7%</li>
<li>多线程基本无锁抢占，多开一个线程减少44%的执行时间。</li>
<li>并行执行对总执行时间有大幅度的优化</li>
</ul>
</li>
<li>通过了cpython的单元测试</li>
<li>在线上已经全量使用</li>
</ul>
<h2 id="cpython痛-gil">cpython痛, GIL</h2>
<p>cpython是python官方的解释器实现。在cpython中，GIL，用于保护对Python对象的访问，从而防止多个线程同时执行Python字节码。GIL防止出现竞争情况并确保线程安全。
因为GIL的存在，cpython 是无法真正的并行执行python字节码的. GIL虽然限制了python的并行，但是因为cpython的代码没有考虑到并行执行的场景，充满着各种各样的共享变量，改动复杂度太高，官方一直没有移除GIL。</p>
<h2 id="挑战">挑战</h2>
<p>在Python开源的20年里，Python 因为GIL（全局锁）不能并行。目前主流实现Python并行的两种技术路线，但是一直没有高完成度的解决方案（高性能，兼容所有开源feature, API稳定）。主要是因为：</p>
<ol>
<li><strong>直接去除GIL 解释器需要加许多细粒度的锁，影响单线程的执行性能，慢两倍。</strong></li>
</ol>
<blockquote>
<p>Back in the days of Python 1.5, Greg Stein actually implemented a comprehensive patch set (the “free threading” patches) that removed the GIL and replaced it with fine-grained locking. Unfortunately, even on Windows (where locks are very efficient) this ran ordinary Python code about twice as slow as the interpreter using the GIL. On Linux the performance loss was even worse because pthread locks aren’t as efficient.</p>
</blockquote>
<ol start="2">
<li><strong>解释器状态隔离 解释器内部的实现充满了各种全局状态，改造繁琐，工作量大。</strong></li>
</ol>
<blockquote>
<p>It has been suggested that the GIL should be a per-interpreter-state lock rather than truly global; interpreters then wouldn’t be able to share objects. Unfortunately, this isn’t likely to happen either. It would be a tremendous amount of work, because many object implementations currently have global state. For example, small integers and short strings are cached; these caches would have to be moved to the interpreter state. Other object types have their own free list; these free lists would have to be moved to the interpreter state. And so on.</p>
</blockquote>
<p>这个思路开源有一个项目在做 <a href="https://github.com/ericsnowcurrently/multi-core-python">multi-core-python</a>,但是目前已经搁置了。目前只能运行非常简单的算术运算的demo。对Type和许多模块的并行执行问题并没有处理，无法在实际场景中使用。</p>
<h2 id="新架构-多解释器架构">新架构-多解释器架构</h2>
<p>为了实现最佳的执行性能，我们参考<a href="https://github.com/ericsnowcurrently/multi-core-python">multi-core-python</a>，在cpython3.10实现了一个高完成度的并行实现。</p>
<ul>
<li>从全局解释器状态 转换为 每个解释器结构持有自己的运行状态（独立的GIL，各种执行状态）。</li>
<li>支持并行，解释器状态隔离，并行执行性能不受解释器个数的影响（解释器间基本没有锁相互抢占）</li>
<li>通过线程的Thread Specific Data获取Python解释器状态。</li>
</ul>
<p>在这套新架构下，Python的解释器相互隔离，不共享GIL，可以并行执行。充分利用现代CPU的多核性能。大大减少了业务算法代码的执行时间。</p>
<h3 id="共享变量的隔离">共享变量的隔离</h3>
<p>解释器执行中使用了很多共享的变量，他们普遍以全局变量的形式存在.多个解释器运行时，会同时对这些共享变量进行读写操作，线程不安全。</p>
<p>cpython内部的主要共享变量：<a href="https://github.com/python/cpython/blob/3.10/Tools/c-analyzer/TODO">3.10待处理的共享变量</a>。</p>
<ul>
<li>free lists
<ul>
<li>MemoryError</li>
<li>asynchronous generator</li>
<li>context</li>
<li>dict</li>
<li>float</li>
<li>frame</li>
<li>list</li>
<li>slice</li>
</ul>
</li>
<li>singletons
<ul>
<li>small integer ([-5; 256] range)</li>
<li>empty bytes string singleton</li>
<li>empty Unicode string singleton</li>
<li>empty tuple singleton</li>
<li>single byte character (b’\x00’ to b’\xFF’)</li>
<li>single Unicode character (U+0000-U+00FF range)</li>
</ul>
</li>
<li>cache
<ul>
<li>slide cache</li>
<li>method cache</li>
<li>bigint cache</li>
<li>&hellip;</li>
</ul>
</li>
<li>interned strings</li>
<li><code>PyUnicode_FromId</code> static strings</li>
<li>&hellip;.</li>
</ul>
<p><strong>如何让每个解释器独有这些变量呢？</strong></p>
<p>cpython是c语言实现的，在c中，我们一般会通过 参数中传递 interpreter_state 结构体指针来保存属于一个解释器的成员变量。这种改法也是性能上最好的改法。但是如果这样改，那么所有使用interpreter_state的函数都需要修改函数签名。从工程角度上是几乎无法实现的。</p>
<p>只能换种方法，我们可以将interpreter_state存放到thread specific data中。interpreter执行时，通过thread specific key获取到 interpreter_state.这样就可以通过thread specific的API，获取到执行状态，并且不用修改函数的签名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> PyInterpreterState<span style="color:#f92672">*</span> <span style="color:#a6e22e">_PyInterpreterState_GET</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    PyThreadState <span style="color:#f92672">*</span>tstate <span style="color:#f92672">=</span> <span style="color:#a6e22e">_PyThreadState_GET</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef Py_DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_Py_EnsureTstateNotNULL</span>(tstate);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> tstate<span style="color:#f92672">-&gt;</span>interp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>共享变量变为解释器单独持有</strong>
我们将所有的共享变量存放到 interpreter_state里。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">/* Small integers are preallocated in this array so that they
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       can be shared.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       The integers that are preallocated are those in the range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       -_PY_NSMALLNEGINTS (inclusive) to _PY_NSMALLPOSINTS (not inclusive).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    PyLongObject<span style="color:#f92672">*</span> small_ints[_PY_NSMALLNEGINTS <span style="color:#f92672">+</span> _PY_NSMALLPOSINTS];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_bytes_state bytes;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_unicode_state unicode;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_float_state float_state;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Using a cache is very effective since typically only a single slice is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       created and then deleted again. */</span>
</span></span><span style="display:flex;"><span>    PySliceObject <span style="color:#f92672">*</span>slice_cache;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_tuple_state tuple;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_list_state list;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_dict_state dict_state;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_frame_state frame;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_async_gen_state async_gen;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_context_state context;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _Py_exc_state exc_state;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> ast_state ast;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> type_cache type_cache;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef PY_NO_SHORT_FLOAT_REPR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _PyDtoa_Bigint <span style="color:#f92672">*</span>dtoa_freelist[_PyDtoa_Kmax <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>通过 <code>_PyInterpreterState_GET</code> 快速访问。
例如</p>
<pre tabindex="0"><code>/* Get Bigint freelist from interpreter  */
static Bigint **
get_freelist(void) {
    PyInterpreterState *interp = _PyInterpreterState_GET();
    return interp-&gt;dtoa_freelist;
} 
</code></pre><p>注意，将全局变量改为thread specific data是有性能影响的，不过只要控制该API调用的次数，性能影响还是可以接受的。
我们在cpython3.10已有改动的的基础上，解决了各种各样的共享变量问题，<a href="https://github.com/python/cpython/blob/3.10/Tools/c-analyzer/TODO">3.10待处理的共享变量</a></p>
<h3 id="type变量共享的处理api兼容性及解决方案">Type变量共享的处理，API兼容性及解决方案</h3>
<p>目前cpython3.x 暴露了Static PyType_xxx 类型变量在API中。这些全局类型变量被第三方扩展代码以&amp;PyType_xxx的方式引用。如果将Type隔离到子解释器中，势必造成不兼容的问题。这也是官方改动停滞的原因，这个问题无法以合理改动的方式出现在python3中。只能等到python4修改API之后改掉。</p>
<p>我们通过另外一种方式快速的改掉了这个问题。</p>
<p>Type是共享变量会导致以下的问题</p>
<ol>
<li>Type Object的 Ref count被频繁修改，线程不安全</li>
<li>Type Object 成员变量被修改，线程不安全。</li>
</ol>
<p>改法：</p>
<ol>
<li>immortal type object.</li>
<li>使用频率低的不安全处加锁。</li>
<li>高频使用的场景，使用的成员变量设置为immortal object.
<ul>
<li>针对python的描述符机制，对实际使用时，类型的property,函数,classmethod,staticmethod,doc生成的描述符也设置成immortal object.</li>
</ul>
</li>
</ol>
<p>这样会导致Python的Type和成员变量会内存泄漏。不过由于cpython有module的缓存机制，不清理缓存时，便没有问题。</p>
<h3 id="pymalloc内存池共享处理">pymalloc内存池共享处理</h3>
<p>我们使用了<a href="https://github.com/microsoft/mimalloc">mimalloc</a>替代pymalloc内存池，在优化1%-2%性能的同时，也不需要额外处理pymalloc。</p>
<h2 id="subinterperter-能力补全">subinterperter 能力补全</h2>
<p>官方master最新代码 subinterpreter 模块只提供了<code>interp_run_string</code>可以执行code_string. 出于体积和安全方面的考虑，我们已经删除了python动态执行code_string的功能。
我们给subinterpreter模块添加了两个额外的能力</p>
<ol>
<li>interp_call_file 调用执行python pyc文件</li>
<li>interp_call_function 执行任意函数</li>
</ol>
<h2 id="subinterpreter-执行模型">subinterpreter 执行模型</h2>
<p>python中，我们执行代码默认运行的是main interpreter, 我们也可以创建的sub interpreter执行代码，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>interp <span style="color:#f92672">=</span> _xxsubinterpreters<span style="color:#f92672">.</span>create()
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> _xxsubinterpreters<span style="color:#f92672">.</span>interp_call_function(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span></code></pre></div><p>这里值得注意的是，我们是在 main interpreter 创建 sub interpreter， 随后在sub interpreter 执行，最后把结果返回到main interpreter. 这里看似简单，但是做了很多事情。</p>
<ol>
<li>main interpreter 将参数传递到 sub interpreter</li>
<li>线程切换到 sub interpreter的 interpreter_state。获取并转换参数</li>
<li>sub interpreter 解释执行代码</li>
<li>获取返回值，切换到main interpreter</li>
<li>转换返回值</li>
<li>异常处理</li>
</ol>
<p>这里有两个复杂的地方：</p>
<ol>
<li>interpreter state 状态的切换</li>
<li>interpreter 数据的传递</li>
</ol>
<h3 id="interpreter-state-状态的切换">interpreter state 状态的切换</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>interp <span style="color:#f92672">=</span> _xxsubinterpreters<span style="color:#f92672">.</span>create()
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> _xxsubinterpreters<span style="color:#f92672">.</span>interp_call_function(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span></code></pre></div><p>我们可以分解为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Running In thread 11:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># main interpreter:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 现在 thread specific 设置的 interpreter state 是 main interpreter的</span>
</span></span><span style="display:flex;"><span>do some things <span style="color:#f92672">...</span> 
</span></span><span style="display:flex;"><span>create subinterpreter <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>interp_call_function <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># thread specific 设置 interpreter state 为 sub interpreter state</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># sub interpreter: </span>
</span></span><span style="display:flex;"><span>do some thins <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>call function <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>get result <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 现在 thread specific 设置 interpreter state 为 main interpreter state</span>
</span></span><span style="display:flex;"><span>get <span style="color:#66d9ef">return</span> result <span style="color:#f92672">...</span>
</span></span></code></pre></div><h3 id="interpreter-数据的传递">interpreter 数据的传递</h3>
<p>因为我们解释器的执行状态是隔离的，在main interpreter 中创建的 Python Object是无法在 sub interpreter 使用的.
我们需要:</p>
<ol>
<li>获取 main interpreter 的 PyObject 关键数据</li>
<li>存放在 一块内存中</li>
<li>在sub interpreter 中根据该数据重新创建 PyObject</li>
</ol>
<p>interpreter  状态的切换 &amp; 数据的传递 的实现可以参考以下示例 &hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">_call_function_in_interpreter</span>(PyObject <span style="color:#f92672">*</span>self, PyInterpreterState <span style="color:#f92672">*</span>interp, _sharedns <span style="color:#f92672">*</span>args_shared, _sharedns <span style="color:#f92672">*</span>kwargs_shared)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>exctype <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>excval <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>tb <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _sharedns <span style="color:#f92672">*</span>result_shread <span style="color:#f92672">=</span> <span style="color:#a6e22e">_sharedns_new</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef EXPERIMENTAL_ISOLATED_SUBINTERPRETERS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Switch to interpreter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PyThreadState <span style="color:#f92672">*</span>new_tstate <span style="color:#f92672">=</span> <span style="color:#a6e22e">PyInterpreterState_ThreadHead</span>(interp);
</span></span><span style="display:flex;"><span>    PyThreadState <span style="color:#f92672">*</span>save1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">PyEval_SaveThread</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">PyThreadState_Swap</span>(new_tstate);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Switch to interpreter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PyThreadState <span style="color:#f92672">*</span>save_tstate <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (interp <span style="color:#f92672">!=</span> <span style="color:#a6e22e">PyInterpreterState_Get</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// XXX Using the &#34;head&#34; thread isn&#39;t strictly correct.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PyThreadState <span style="color:#f92672">*</span>tstate <span style="color:#f92672">=</span> <span style="color:#a6e22e">PyInterpreterState_ThreadHead</span>(interp);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// XXX Possible GILState issues?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        save_tstate <span style="color:#f92672">=</span> <span style="color:#a6e22e">PyThreadState_Swap</span>(tstate);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>module_name <span style="color:#f92672">=</span> <span style="color:#a6e22e">_PyCrossInterpreterData_NewObject</span>(<span style="color:#f92672">&amp;</span>args_shared<span style="color:#f92672">-&gt;</span>items[<span style="color:#ae81ff">0</span>].data);
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>function_name <span style="color:#f92672">=</span> <span style="color:#a6e22e">_PyCrossInterpreterData_NewObject</span>(<span style="color:#f92672">&amp;</span>args_shared<span style="color:#f92672">-&gt;</span>items[<span style="color:#ae81ff">1</span>].data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>module <span style="color:#f92672">=</span> <span style="color:#a6e22e">PyImport_ImportModule</span>(<span style="color:#a6e22e">PyUnicode_AsUTF8</span>(module_name));
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>function <span style="color:#f92672">=</span> <span style="color:#a6e22e">PyObject_GetAttr</span>(module, function_name);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> <span style="color:#a6e22e">PyObject_Call</span>(function, args, kwargs);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef EXPERIMENTAL_ISOLATED_SUBINTERPRETERS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Switch back.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">PyEval_RestoreThread</span>(save1);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Switch back.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (save_tstate <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PyThreadState_Swap</span>(save_tstate);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result) {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> <span style="color:#a6e22e">_PyCrossInterpreterData_NewObject</span>(<span style="color:#f92672">&amp;</span>result_shread<span style="color:#f92672">-&gt;</span>items[<span style="color:#ae81ff">0</span>].data);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_sharedns_free</span>(result_shread);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="实现子解释器池">实现子解释器池</h2>
<p>我们已经实现了内部的隔离执行环境，但是这是API比较低级，需要封装一些高度抽象的API，提高子解释器并行的易用能力。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>interp <span style="color:#f92672">=</span> _xxsubinterpreters<span style="color:#f92672">.</span>create()
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> _xxsubinterpreters<span style="color:#f92672">.</span>interp_call_function(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span></code></pre></div><p>这里我们参考了，python concurrent库提供的 thread pool, process pool, futures的实现，自己实现了 subinterpreter pool. 通过concurrent.futures 模块提供异步执行回调高层接口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>executer <span style="color:#f92672">=</span> concurrent<span style="color:#f92672">.</span>futures<span style="color:#f92672">.</span>SubInterpreterPoolExecutor(max_workers)
</span></span><span style="display:flex;"><span>future <span style="color:#f92672">=</span> executer<span style="color:#f92672">.</span>submit(_xxsubinterpreters<span style="color:#f92672">.</span>call_function, module_name, func_name, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>future<span style="color:#f92672">.</span>context <span style="color:#f92672">=</span> context
</span></span><span style="display:flex;"><span>future<span style="color:#f92672">.</span>add_done_callback(executeDoneCallBack)
</span></span></code></pre></div><p>我们内部是这样实现的:
继承 concurrent 提供的 Executor 基类</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SubInterpreterPoolExecutor</span>(_base<span style="color:#f92672">.</span>Executor):
</span></span></code></pre></div><p>SubInterpreterPool 初始化时创建线程，并且每个线程创建一个 sub interpreter</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>interp <span style="color:#f92672">=</span> _xxsubinterpreters<span style="color:#f92672">.</span>create()
</span></span><span style="display:flex;"><span>t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(name<span style="color:#f92672">=</span>thread_name, target<span style="color:#f92672">=</span>_worker,
</span></span><span style="display:flex;"><span>                     args<span style="color:#f92672">=</span>(interp, 
</span></span><span style="display:flex;"><span>                           weakref<span style="color:#f92672">.</span>ref(self, weakref_cb),
</span></span><span style="display:flex;"><span>                           self<span style="color:#f92672">.</span>_work_queue,
</span></span><span style="display:flex;"><span>                           self<span style="color:#f92672">.</span>_initializer,
</span></span><span style="display:flex;"><span>                           self<span style="color:#f92672">.</span>_initargs))
</span></span></code></pre></div><p>线程 worker 接收参数，并使用 interp 执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>result <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>fn(self<span style="color:#f92672">.</span>interp ,<span style="color:#f92672">*</span>self<span style="color:#f92672">.</span>args, <span style="color:#f92672">**</span>self<span style="color:#f92672">.</span>kwargs)
</span></span></code></pre></div><h2 id="实现外部调度模块">实现外部调度模块</h2>
<p>针对sub interpreter的改动较大，存在两个隐患</p>
<ol>
<li>代码可能存在兼容性问题，第三方C/C++ Extension 实现存在全局状态变量，非线程安全。</li>
<li>python存在着极少的一些模块.sub interpreter无法使用。例如process</li>
</ol>
<p>我们希望能统一对外的接口，让使用者不需要关注这些细节，我们自动的切换调用方式。自动选择在主解释器使用（兼容性好,稳定）还是子解释器（支持并行，性能佳）</p>
<p>我们提供了C和python的实现，方便业务方在各种场景使用，这里介绍下python实现的简化版代码。</p>
<p>在bddispatch.py 中，抽象了调用方式，提供统一的执行接口，统一处理异常和返回结果。
bddispatch.py</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">executeFunc</span>(module_name, func_name, context<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, use_main_interp<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;submit call &#34;</span>, module_name, <span style="color:#e6db74">&#34;.&#34;</span>, func_name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> use_main_interp <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        exception <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>            m <span style="color:#f92672">=</span> __import__(module_name)
</span></span><span style="display:flex;"><span>            f <span style="color:#f92672">=</span> getattr(m, func_name)
</span></span><span style="display:flex;"><span>            r <span style="color:#f92672">=</span> f(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">=</span> r
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>:
</span></span><span style="display:flex;"><span>            exception <span style="color:#f92672">=</span> traceback<span style="color:#f92672">.</span>format_exc()
</span></span><span style="display:flex;"><span>        singletonExecutorCallback(result, exception, context)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        future <span style="color:#f92672">=</span> singletonExecutor<span style="color:#f92672">.</span>submit(_xxsubinterpreters<span style="color:#f92672">.</span>call_function, module_name, func_name, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        future<span style="color:#f92672">.</span>context <span style="color:#f92672">=</span> context
</span></span><span style="display:flex;"><span>        future<span style="color:#f92672">.</span>add_done_callback(executeDoneCallBack)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">executeDoneCallBack</span>(future):
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">=</span> future<span style="color:#f92672">.</span>result()
</span></span><span style="display:flex;"><span>    e <span style="color:#f92672">=</span> future<span style="color:#f92672">.</span>exception()
</span></span><span style="display:flex;"><span>    singletonExecutorCallback(r, e, future<span style="color:#f92672">.</span>context)
</span></span></code></pre></div><h2 id="直接绑定到子解释器执行">直接绑定到子解释器执行</h2>
<p>对于性能要求高的场景，通过上述的方式，由主解释器调用子解释器去执行任务会增加性能损耗。
这里我们提供了一些CAPI, 让直接内嵌cpython的使用方通过C API直接绑定某个解释器执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AccquireGIL</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    AccquireGIL() {
</span></span><span style="display:flex;"><span>        inter_ <span style="color:#f92672">=</span> BDPythonVMDispatchGetInterperter();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (inter_ <span style="color:#f92672">==</span> PyInterpreterState_Main()) {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;Ensure on main interpreter: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, inter_);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;Ensure on sub interpreter: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, inter_);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        gil_ <span style="color:#f92672">=</span> PyGILState_EnsureWithInterpreterState(inter_);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>AccquireGIL() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (inter_ <span style="color:#f92672">==</span> PyInterpreterState_Main()) {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;Release on main interpreter: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, inter_);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;Release on sub interpreter: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, inter_);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        PyGILState_Release(gil_);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    PyInterpreterState <span style="color:#f92672">*</span>inter_;
</span></span><span style="display:flex;"><span>    PyGILState_STATE gil_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这样就可以自动绑定到一个解释器直接执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">-</span> (<span style="color:#66d9ef">void</span>)testNumpy {
</span></span><span style="display:flex;"><span>    AccquireGIL gil_guard;
</span></span><span style="display:flex;"><span>    BDPythonVMRun(....);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="招聘">招聘</h2>
<blockquote>
<p>字节跳动 招聘 Python虚拟机优化方向，工作内容主要为优化cpython解释器，优化cpythonJIT（自研），优化cpython常用三方库。欢迎联系 微信: <strong>xiejunyiiii</strong>。邮箱: <strong><a href="mailto:xiejunyi.arch@bytedance.com">xiejunyi.arch@bytedance.com</a></strong></p>
</blockquote>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/python/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">python</a>
   </li>
  
   <li class="list di">
     <a href="/tags/interpreter/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">interpreter</a>
   </li>
  
   <li class="list di">
     <a href="/tags/optimization/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">optimization</a>
   </li>
  
   <li class="list di">
     <a href="/tags/performance/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">performance</a>
   </li>
  
   <li class="list di">
     <a href="/tags/parallel/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Parallel</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/about/">About</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  xiejunyi blog 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
