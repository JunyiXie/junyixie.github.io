<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>interpreter on xiejunyi blog</title>
    <link>http://localhost:1313/tags/interpreter/</link>
    <description>Recent content in interpreter on xiejunyi blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 31 Aug 2022 15:43:48 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/interpreter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Interpreter performance optimization and design key papers</title>
      <link>http://localhost:1313/post/interpreter-performance-optimization-design-references/</link>
      <pubDate>Wed, 31 Aug 2022 15:43:48 +0800</pubDate>
      
      <guid>http://localhost:1313/post/interpreter-performance-optimization-design-references/</guid>
      <description>Introduction In the past two years, when I was working in ByteDance, I did a lot of work on the design and optimization the Python interpreter. This article lists the papers that I find very helpful.
https://www.reddit.com/r/programming/comments/wzrcb/implementing_fast_interpreters/
Vmgenâ€”a generator of efficient virtual machine interpreters
https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.16.7676&amp;amp;rep=rep1&amp;amp;type=pdf
Trace-based just-in-time type specialization for dynamic languages
Optimization of dynamic languages using hierarchical layering of virtual machines
Virtual machine showdown: Stack versus registers
Virtual-Machine Abstraction and Optimization Techniques</description>
    </item>
    
    <item>
      <title>Python Interpreter Performance Optimizations In 3.6 ~ 3.11</title>
      <link>http://localhost:1313/post/python-performance-optimizations-between-3.6-and-3.11.md/</link>
      <pubDate>Sun, 31 Jul 2022 15:43:48 +0800</pubDate>
      
      <guid>http://localhost:1313/post/python-performance-optimizations-between-3.6-and-3.11.md/</guid>
      <description>3.11 Cheaper, lazy Python frames, 3-7% speedup in pyperformance (Contributed by Mark Shannon in bpo-44590.) Streamlined the frame creation process. Avoided memory allocation by generously re-using frame space on the C stack. Streamlined the internal frame struct to contain only essential information. Frames previously held extra debugging and memory management information. Inlined Python function calls, measured a 1-3% improvement in pyperformance. (Contributed by Pablo Galindo and Mark Shannon in bpo-45256.) In 3.</description>
    </item>
    
  </channel>
</rss>
